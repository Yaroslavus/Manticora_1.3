Manticore 1.3 - программа, предназначенная для обработки сырых данных с черенковского атмосферного телескопа Тункинской
астрофизической обсерватории. Данное руководство написано с целью максимально подробно проинформировать о том, что
происходит внутри нее, когда она работает.

Данная программа является бета-бета-бета версией, поэтому советую вовсю интересоваться ее обновлениями и дополнениями.
Если она вообще выживет.

Сагань Ярослав
-------------------------------------------------------------------------------------------------------------------------
Пакетные требования:

- python3
	(execute in shell 'sudo apt-get install python3)
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

1. Данные TAIGA-IACT. Структура и формат.

#########################################################################################################################

Камера IACT разделена на 22 кластера по 28 ФЭУ. Сигнал каждого ФЭУ расщепляется на два усилителя с целью повышения
динамического диапазона и приходит с них на Read-out плату MAROC-3 по двум каналам – с большим усилением и малым
усилением. Таким образом на вход платы MAROC-3 приходят сигналы с 56 каналов. Данные с каждого кластера проходят через
собственную плату MAROC-3.

Обзор файлового дерева данных TAIGA-IACT.
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
Все данные, снятые за одну дату, находятся в папке, именованной этой датой, к примеру, “281017” (ddmmyy). Если в эту дату
было несколько запусков, то они именуются “ddmmyy”, “ddmmyy.01”, “ddmmyy.02 и т.д.”

Каждая папка с датой содержит в себе следующие папки:

“BSMxx”, где xx – номер кластера (xx = 01, 02, 03, …, 22) – 22 папки, содержащие файлы с сырыми данными.
PED – папка, содержащая файлы с сырыми пьедесталами, по одному на кластер.
CURRENT – сырые файлы, содержащие токи с кластеров, по одному на кластер.
CORATE – содержит сырые файлы с темпами счета кластеров, по одному на кластер.

Каждая папка с датой содержит также следующие одиночные файлы:

startrun.txt – файл с информацией о синхронизации с GPS перед запуском сбора данных, а также время старта сбора данных.
iact_overcur.txt – информация о превышениях токовых порогов (включая амплитуды каналов по кластерам).
iact_status.txt – файл, в который происходил подробный вывод статуса программы сбора данных в течении RUN-а.
iact_corate.txt – темпы счета кластеров (наличие файла опционно – в случае, если проверка производилась).

Обзор папок:
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
PED:

Перед RUN-ом на кластерах считываются около 800-1000 пьедесталов с каждого (чаще всего 1000) методом случайного триггера.
Данные по пьедесталам каждого кластера пишутся в один файл с именем в формате “ddmmyyxx.ped”.

BSMxx:

С выхода 12-битного АЦП данные каналов приходят для записи в виде кодов АЦП, которые позже надо будет преобразовывать в
амплитуды. В папке находится N файлов, где N = Время RUN-а/2 мин. В каждом файле – данные, записанные за 2 минуты. Каждые
две минуты файл закрывается для записи и открывается новый пустой. Файлы именованы в формате “ddmmyyxx.zzz”, где yy – год,
запианный по правилам, указанным для папок CORATE и CURRENT, xx – номер кластера, а zzz – номер “двухминутки”.
Пример имени:
“28107001.005” - пятая двухминутка первого кластера за 28.10.2017.
“281007005.001” - первый файл (первая двухминутка) пятого кластера за 28.10.2017.
Папки CORATE и CURRENT – результаты постобработки.

CORATE:

В течении RUN-а с каждого кластера снимаются темпы счета. Темпы счета каждого кластера записываются в один файл с именем
в формате “ddmmyyxx.corate”, где xx – номер кластера. Важно!!! Если год < 2020, то yy – это 70 для 2017, 80 для 2018,
90 для 2019. Начиная с 2020 обычный yy. xx нумеруются с 1 по 22.

CURRENT:

В течении RUN-а с каждого кластера снимается выходной ток. Ток каждого кластера записывается в один файл с именем в
формате “ddmmyyxx.current”, где xx – номер кластера. Важно!!! Если год < 2020, то yy – это 70 для 2017, 80 для 2018,
90 для 2019. Начиная с 2020 обычный yy. xx нумеруются с 1 по 22.

Формат данных TAIGA-IACT.
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

Имя каждого файла с данными:

"Директория_с_данными/DDMMYY(.NN)/BSMxx/ddmmyyxx.zzz"

В каждый файл пишется байтовый поток, разбитый на “события”. Каждое событие в байтовом виде представляет из себя пакет,
идентичный остальным пакетам в файле. В одном файле – примерно 30 тыс. пакетов.

Формат пакета сырых данных:

Пакет состоит из заголовка с метаинформацией по данному событию и, собственно, самих кодов АЦП.
Размер всего пакета – 156 байт. Размер заголовка – 24 байта.

Формат пакета:
#########################################################################################################################
Заголовок:

Байты 0-1 – идентификатор типа данных (должен быть равен 3032)
Байты 2-3 – размер пакета без заголовка (равен 132)
Байты 4-7 – номер 1
Байты 8-11 – номер 2
Байты 12-19 – время события.
Байт 20 – номер MAROC (равен номеру кластера). Номер лежит в 5 младших битах (справа).
Байт 21-23 – пустые байты.

Данные:

Байты 24-132 – данные.
Байты 132 – 155 – флаг конца пакета (равен 0xffffffff или -1).

Данные занимают 128 байт. Т.к.  у MAROC 64 выходных канала (из них 56 физических по два канала на каждый из 28 ФЭУ),
каждый канал кодируется 2 байтами. В итоге получается следующий порядок кодировки:

0_pmt_low_channel – 2 байта.
0_pmt_high_channel – 2 байта.
1_pmt_ low_channel – 2 байта.
1_pmt_ high_channel – 2 байта.
2_pmt_ low_channel – 2 байта.
2_pmt_ high_channel – 2 байта.
...
31_pmt_ low_channel – 2 байта.
31_pmt_ high_channel – 2 байта.

Так как у MAROC 64 канала, а в кластере 28 ФЭУ, то задействовано только 56 каналов.
Вхолостую работают каналы 0, 1, 30, 31. В них нет физических данных. Помимо этого каналы с высоким усилением служат для
фиксации темпов счета в папке CORATE и токов в папке CURRENT.


Пьедесталы.
#########################################################################################################################
Имя каждого файла с пьедесталами:

Директория_с_данными/DDMMYY(.NN)/PED/ddmmyyxx.ped

Файл также разбит на пакеты с событиями. Каждый пакет имеет конструкцию, полностью идентичную пакетам с данными.

#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

2. Обзор файлов manticore 1.3.

#########################################################################################################################

Программа manticore 1.3 предназначена для предобработки сырых данных TAIGA-IACT и состоит из следующих компонент:

- данное руководство;
- файлы интерфейса;
- библиотеки;
- запускающий BASH-скрипт.
- доп. файл msu_grid_ssh_access.sh, не принимающий участия в работе программы, но открывающий папку с данными TAIGA-IACT
на ферме МГУ из под логина и пароля автора.

manticore 1.3 полностью написана на Python 3.6 и не содержит сторонних библиотек. Соответственно, системные требования:

- наличие python 3.6
- наличие BornAgainShell (BASH)

Весь стиль кода соответствует стандарту PEP-8 от 7,9/10 до 10/10 (в зависимости от библиотеки)

#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

Файлы интерфейса:

1. data_directory.config – содержит строку с абсолютным адресом папки с данными на данной машине. К примеру,
“/home/yaroslav/Yaroslavus_GitHub/DATA”.

2. input_card.txt – карта входных данных. Здесь можно выбрать, что и с какими опциями предобрабатывать. Подробности
описаны в самом файле.

3. manticore_stdout_slow.txt - весь вывод в консоль при последнем запуске программы в медленном режиме сохраняется
здесь. ВАЖНО! Перезаписывается при каждом новом запуске в медленном режиме.

4. manticore_stdout_fast.txt - весь вывод в консоль при последнем запуске программы в быстром режиме (с паралелльными
вычислениями) сохраняется здесь. ВАЖНО! Перезаписывается при каждом новом запуске в быстром режиме.

Запускающий BASH-скрипт

1. manticore.sh – запускаемый файл. Запускается командой ./manticore.sh из BASH. Если BASH отвечает, что нет прав для
запуска, предварительно однократно выполните команду:
~$ chmod +x manticore.sh в папке manticore_1.3.
ВАЖНО! Принимает флаг режима скорости (параллельности):

~$ ./manticore.sh -f

будет означать, что используются параллельные вычисления. Очень быстро, но вывод в консоль более беспорядочен, так как
в нее пишут параллельно 4-8 процессов.  

~$ ./manticore.sh -s

будет означать, что параллельные вычисления не используются. Относительно медленно, но вывод в консоль последоватеен,
так как в каждый момент времени в нее пишет один и только один текущий процесс.

Любые другие флаги либо отсутствие флага выдаст ошибку.

4. Библиотеки:

1. manticore_parser.py. Содержит одну функцию universal_parser, которая принимает на вход строку с данными для обработки.
Создает в папке manticore_1.3 временный файл .files_list.txt, в котором содержатся все файлы, которые подлежат
предобработке. Подробнее о работе функции – в пункте 3.

2. manticore_tools.py – содержит в себе большинство мелких функций, необходимых при работе программы. К примеру, сборщик
мусора (временных файлов) mess_destroyer, считыватель input_card.txt read_input_card, таймер time_check и т.д. Все
стандартные библиотеки импортируются именно в нее. Другие файлы не принимают стандартных библиотек. Подробнее о работе
функций – в пункте 3.

3. manticore_preprocessing.py – содержит в себе функции, касающиеся непосредственно распаковки сырых бинарных файлов,
вычисления пьедесталов, рассчета амплитуд, очищенных от пьедесталов, запаковки их в выходные бинарные файлы, анализа и
формирования выходной информации. Подробнее о работе функций – в пункте 3.

4. manticore_multiprocessing.py - содержит в себе функции, касающиеся параллельных вычислений. По сути эта библиотека
сформирована так: функции из manticore_preprocessing, которые непосредственно запускают большие блоки процессов,
переписаны так, чтобы они могли запускать процессы не один за другим а блок за блоком (от 4 до 8 процессов в блоке).
Примерно во столько раз при использовании этой библиотеки растет и общая скорость выполнения программы.

5. manticore_main_slow.py – главный менеджер всего процесса предобработки. В нем:
- в нужном порядке запускаются скрипты из других библиотек manticore;
- хранятся входные переменные файла input_card.txt – главные 4 переменных всей программы. Именно оттого, что они
хранятся здесь, они доступны остальным функциям.
- ведется рассчет времени, которое занимает весь процесс предобработки.
ИСПОЛЬЗУЕТ ИСКЛЮЧИТЕЛЬНО БИБЛИОТЕКУ manticore_preprocessing.py.

6. manticore_main_fast.py - то же, что и manticore_main_slow.py, только с использованием функций для параллельных вычислений
из библиотеки manticore_preprocessing.py.
При запуске программы можно выбрать  - FAST или SLOW (с помощью флага при запуске ./manticore.sh). Опция SLOW осталась
по следующей причине: при работе модуля с параллельными вычислениями вывод консоли теряет всякий порядок, так как в него
пишут параллельно около 8 процессов. Поэтому сложнее следить визуально за выполнением. Для лучшего контроля вывода
консоли можно запустить SLOW режим. Там все будет по порядку.
Также при исполнении FAST-версии иначе заполняется файл временных файлов .mess.txt, необходимый для сборщика мусора
mess_destroyer из библиотеки manticore_tools. Файлы в нем расположены не по порядку. Подробности - в разделе о функции
to_process_mult из библиотеки manticore_multiprocessing.
ИСПОЛЬЗУЕТ БИБЛИОТЕКУ manticore_multiprocessing.py

Посторонние файлы и папки

Есть вероятность того, что в директории скрипта будут находиться следующие файлы и директории, никак не влияющие на
работу программы:

- .gitignore - файл, ответственный за порядок работы с git-репозиторием.
- __pycache__ - директория, содержащая все файлы из директории скрипта с расширением .py, но уже скомпилированные в
байт-код.
- .git - директория, содержащая файлы, необходимые для корректной работы git-репозитория.
- .spyproject - директория, несущая информацию о том, как с этим проектом работает IDE Spyder.

#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

2. Обзор функций manticore 1.3.

#########################################################################################################################

manticore_main_slow.py:

Не содержит функций.

manticore_main_fast.py:

Не содержит функций.

manticore_preprocessing.py:

to_process(start_time)

Принимает файл с файлами, подлежащими к обработке – .files_list.txt и в цикле, по одному, скармливает их функции
to_process_single_file(file). Это и есть основной цикл, работающий подавляющую часть времени работы программы
manticore 1.3. Также в этом цикле организует практически весь стандартный вывод программы, например,
syprogressbar(i, sum), time_check(start_time). В конце выводит время, прошедшее с начала создания файлов, пользуясь
функцией time_check(start_time).

to_process_single_file(file)

В процессе обработки файла file создается 5 временных файлов, имеющих различный разрешения. Пусть файл
file = data_dir/DDMMYY/BSMxx/file_name.zzz. Тогда создадутся следующие временные файлы:
1.  data_dir/DDMMYY/PED/.file_name.fpd
2.  data_dir/DDMMYY/PED/.file_name.sgm
3.  data_dir/DDMMYY/PED/.file_name.ig
4.  data_dir/DDMMYY/BSMxx/.file_name.zzz.hdr
5.  data_dir/DDMMYY/BSMxx/.file_name.zzz.wfp.

Файл .fpd – файл с пьедесталами. Имеет размер 256 байт и содержит подряд 64 числа типа float (по 4 байта). Каждое число –
значение пьедестала. Порядковый номер каждого пьедестала равен номеру канала.

Файл .sgm – файл с сигмами пьедесталов. Имеет размер 256 байт и содержит подряд 64 числа типа float (по 4 байта). Каждое
число – значение сигмы пьедестала. Порядковый номер каждого пьедестала равен номеру канала.

Файл .ig – файл с игнор-статусами пьедесталов. Каждый игнор-статус может быть равен 0, 1, 2 или 3. Подробнее – в разделе
о функции make_pedestals(). Файл имеет размер 64 байта и содержит подряд 64 числа типа char. Порядковый номер каждого
игнор-статуса равен номеру канала.

Файл .wfp – файл с амплитудами, очищенными от пьедесталов, метками триггера (0 или 1) и игнор-статусами. Подробнее – в
разделе о функции make_clean_amplitudes_and_headers(). Соостоит из последовательных одинаковых пакетов размером в 282
байта.

Файл .hdr – то же, что и .wfp, но содержит только номера и время событий. Пакет имеет размер 16 байта. Подробнее – в
разделе о функции make_clean_amplitudes_and_headers().

Функция проверяет в необходимых директориях наличие каждого файла. Если нет хотя бы одного файла из .fpd, .sgm или .ig,
запускает функцию make_pedestals(). Здесь же в .mess.txt вносится строка о создании этих временных файлов. Если нет
хотя бы одного из .wfp, .hdr – запускает make_clean_amplitudes_and_headers(). Здесь же в .mess.txt вносится строка о
создании этих временных файлов. Для каждого сырого файла .zzz нужен только один запуск make_pedestals(). 

Более подробная информация о структуре временных файлов – в разделе 4.

make_pedestals(file)

Функция принимает файл file и ищет его пьедестал. Его существование уже проверено на уровень выше – в функции
to_process_single_file(file). Его точно нет. Итак, найдя пьедестальный файл, функция читает его пакет за пакетом. Файл
с пьедесталами зачастую содержит 800-1000 пакетов.
Вначале создается массив FPD размером 64. Затем – пакет за пакетом:
- к каждому FPD[i] прибавляется значение данного пьедестала в этом пакете;
- счетчик пакетов увеличивается на 1.
Каждый пьедестал в пакете кодируется двумя байтами. Значение пьедестала вычисляется следующим образом:
FPD[i] = (byte_chunk[i+1]*256 + byte_chunk[i])/4
После прохождения всех пакетов каждое значение FPD[i] делится на счетчик. В итоге FPD содержит средние значения
всех пьедесталов.

Массив FPD_sigma считается по следующей формуле:
FPD_sigma = FPD**2 - (FPD_av*n)/(n – 1), где
FPD – массив пьедесталов из файла,
FPD_av – среднее значение пьедесталов из FPD,
n – количество пакетов с пьедесталами.

Массив IG считается следующим образом:
1. Вычисляется среднее значение SGM_av.
2. Для каждого канала вычисляется значение FPD_sigma[i] > abs(FPD_av[i] + 3*SGM_av),
где abs() - модуль числа.
Если значение True, то каналу присваивается игнор-статус равный 0.
Если значение False и канал – с низким усилением, то каналу присваивается игнор-статус равный 1.
Если значение False и канал – с высоким усилением, то каналу присваивается игнор-статус равный 2.
Таким образом, ФЭУ, у которого оба канала “вывалились” за 3*сигма, имеет игнор-статус 3.
ФЭУ, у которого оба канала не “вывалились” за 3*сигма, имеет игнор-статус 0.
Таким образом, ФЭУ, у которого канал с высоким усилением “вывалился” за 3*сигма, имеет игнор-статус 2.
Таким образом, ФЭУ, у которого канал с низким усилением “вывалился” за 3*сигма, имеет игнор-статус 1.

make_clean_amplitudes_and_headers(file)

Функция пакет за пакетом принимает файл file. С каждым пакетом производятся следующие действия:
Для каждого канала, закодированного двумя байтами, вычисляется его амплитуда по формуле:
1. AMP[i] = (byte_chunk[i+1]*256 + byte_chunk[i])/4
2. От амплитуды каждого канала отнимается соответствующий ему пьедестал (соответствие пьедестальных файлов и
файлов данных см. Описание функции to_process_single_file(file)). В итоге амплитуда каждого канала – значение типа
float (4 байта). В амплитуду кладется амплитуда канала с высоким усилением, если его амплитуда не превышает 1800.
Если превышает – то канала с низким усилением.
3. Вычисляется статус триггера для каждого канала. Статус триггера равен последнему биту кода канала с низким усилением.
1 – значит триггер, 0 – значит не триггер. Статус триггера – значение типа unsigned char (1 байт).
Пакет пишется в файл по следующему правилу:
1. Пишется неизмененный заколовок (байты 0-23).
2. Пишется измененный блок с данными (байты 24-215).
3. Пишется неизмененный флаг конца пакета (216-219).

Блок данных представляет из себя 32 одинаковых звена размером в 6 байт. Каждое звено содержит амплитуду канала
(float – 4 байта), статус триггера (unsigned char – 1 байт) и игнор-статус (unsigned char – 1 байт).

def dict_of_num_min_max_in_tail(tail, files_list, day):

tail - это идентификатор "двухминутки". В файле с именем "Директория_с_данными/DDMMYY(.NN)/BSMxx/ddmmyyxx.zzz"
tail-ом является zzz. Данная функция находит все файлы с одним "хвостом" (tail) в параллельных BSM-ах Таким образом все
эти файлы были сформированы в одни и те же 2 минуты. Затем функция проверяет ВСЕ номера событий, присутствующие в этих
(в общем случае 22-х) файлах и возвращает минимальный и максимальный номера.

def set_of_days(files_list):

Принимает .files_list.txt и возвращает множество, содержащее все дни, присутствующие в нем в виде
"Директория_с_данными/DDMMYY(.NN)" (множество строк).

def set_of_tails(files_list, day):

Принимает запись из множества дней (см. предыдущую функцию) и возвращает множество, содержащее все "хвосты",
присутствующие в нем в виде "zzz" (множество строк).

def count_tails_range(start_time):

Функция "оборачивает" предыдущие три. Принимая на вход .files_list.txt, она возвращает словарь словарей следующего
вида:
dictionary_of_days = {'Директория_с_данными/DDMMYY(.NN)': {tail: [min_event_number, mzx_event_number]}
						    	  {tail: [min_event_number, mzx_event_number]}
						    	  {tail: [min_event_number, mzx_event_number]}
						    	  ............................................
	              'Директория_с_данными/DDMMYY(.NN)': {tail: [min_event_number, mzx_event_number]}
						    	  {tail: [min_event_number, mzx_event_number]}
						    	  {tail: [min_event_number, mzx_event_number]}
						    	  ...........................................}

def print_statistics_for_matrix_of_events(matrix_of_events):

Принимает очищенную от фиктивных (0 совпадений) событий и выводит статистику по ней в следующем виде:

Совпадения	0	количество событий	0
Совпадения	1	количество событий	число
Совпадения	2	количество событий	число
.................................................
Совпадения	22	количество событий	0

Число 0-совпадений всегда 0, так как матрица уже очищена.

def list_of_tail_files(day_directory, list_of_BSM, tail):

Принимает один "хвост" и создает список всех файлов с этим хвостом за день day_directory. Принимает также и список
BSM, так что уже знает и где искать.

def fill_the_matrix_of_events(matrix_of_events, tail_files, tail, start_time):

Непосредственно перебирает все tail файлы из tail_files, находит их .wfp файлы, открывает, считывает пособытийно,
распаковывает байт-пакеты и пишет нужную информацию в матрицу в виде строк. Каждый элемент матрицы[i][j] - это
строка, в которой содержится информация об ответе BSM[j] на событие i.
Эта строка выглядит так:

"BSM_number	TIME	AMPL[0] TRIGGER_STATUS[0] IGNORE_STATUS[0] ... AMPL[63] TRIGGER_STATUS[63] IGNORE_STATUS[63]"

от 0-го канала до 63-го канала в данном BSM (кластере).

def create_summary_file_for_tail(tail, tail_max_min_list, start_time,

Запускается в цикле для каждого "хвоста" из списка "хвостов". Делает следующее:

- создает матрицу событий по данному "хвосту". Матрица событий - это конструкция, в которой каждая строка - это
событие, а i-тый элемент строки - вся информация с i-того BSM по этому событию. Эта информация - строка из .wfp
всех файлов по этому "хвосту". Один элемент матрицы содержит информацию по всем каналам, их игнор-статусам и
триггер-статусам.
- заполняет эту матрицу, читая файлы (функция fill_the_matrix_of_events).
- чистит эту матрицу от фиктивных событий (в которых не сработал ни один BSM).
- записывает эту матрицу в файл tail.out.
- выводит статистику по количеству событий с совпадениями (1-BSM, 2-BSM etc. - функция
print_statistics_for_matrix_of_events).

def clean_the_matrix_of_events(matrix_of_events):

Получает на вход матрицу событий. Фиктивное событие - это событие, в котором не сработал ни один BSM. Для строки
с номером такого события все элементы - пустые строки, так как каждый элемент - это запись о реакции
соответствующего BSM на данное событие. Функция возвращает ту же матрицу, но уже без таких строк.

def fill_the_summary_files(dict_of_days, start_time):

Уже упоминалось, что сырой файл data_dir/DDMMYY/BSMxx/file_name.(zzz) содержит в себе данные за 2 минуты. Следующие
две минуты пишутся уже в файл data_dir/DDMMYY/BSMxx/file_name.(zzz + 1). В итоге в 22 папках data_dir/DDMMYY/BSMxx
(где xx = 01 ... 22) образуется 22 файла, содержащих данные за одну параллельную двухминутку по 22-м кластерам.
Данная функция создает в папке data_dir/DDMMYY/ текстовый файл под именем zzz.sum, в котором содержится одно за другим
каждое событие, зафиксированное за эти две минуты хотя бы одним кластером. Каждое событие записано в 24 строки следующим
образом:
1 строка – номер события X.
22 строки – показания кластеров в этом событии.
23 строка – пустая.
Если в файле данной двухминутки данного кластера не было события номер X, строка остается пустой.
Показания кластеров записываются следующим образом:
event_time ampl_1 trig_1 ig_1 ampl_2 trig_2 ig_2 ampl_3 trig_3 ig_3 … ampl_32 trig_32 ig_32,
где ampl_n – амплитуда ФЭУ номер n, trig_n – статус триггера ФЭУ n, ig_n – игнор-статус ФЭУ n.

Важно! Файлы  zzz.sum не временные! Их нет в файле .mess.txt. Поэтому и мусоросборщик их не удалит, даже если его запустить!
Следите за чистотой в рабочих директориях!

manticore_tools.py:

syprogressbar(i, sum)

Полоса статуса выполнения задачи. Импортируется в любой цикл.

is_preprocessing_needed(set_1, start_time)

Проверяет set_1. Если пользователь не хочет делать предобработку, он может:
- удалить все временные файлы, оставшиеся после предыдущей предобработки этих же данных (если они остались, то при новой
предобработке могут быть перезаписаны!). В этом случае запускается скрипт mess_destroyer() данной библиотеки.
- создать только список файлов, подлежащих обработке (.files_list.txt), но не обрабатывать их. Служит для проверки
корректности. Функция для отладчиков и разработчиков.
- создать только список файлов, подлежащих обработке (.files_list.txt), но не обрабатывать их, а также создать список
всех временных файлов, которые были бы созданы, если бы предобработка была запущена (.mess.txt). Служит для проверки
корректности. Функция для отладчиков и разработчиков.

В конце выводит время, прошедшее с начала создания файлов, пользуясь функцией time_check(start_time).

data_dir()

Счиывает из файла data_directory.config адрес директории с данными и возвращает его строкой.

mess_destroyer()

Удаляет все временные файлы, прописанные в файле .mess.txt в директории manticore_1.3. Последним удаляет файл .mess.txt.
Важно! Если по каким-то причинам временный файл был создан, остался на диске, но не записан в .mess.tst, он не будет
удален!
В конце выводит время, прошедшее с начала удаления файлов, пользуясь функцией time_check(start_time).
Удобство данной функции состоит в том, что ее можно запустить просто из консоли ipython или из любой другой оболочки
интерпретатора python. И она отработает так же, как и из основной программы. Лишь вместо start_time придется подставить
любое число, например 0.

make_BSM_file_temp(file)

Принимает строку с абсолютным именем сырого файла с данными и возвращает строку с именем такого же, но временного файла.
data_dir/DDMMYY/BSMxx/file_name → data_dir/DDMMYY/BSMxx/.file_name

make_PED_file_temp(file)

Принимает строку с абсолютным именем сырого файла с данными и возвращает строку с именем такого же, но временного файла.
data_dir/DDMMYY/PED/file_name → data_dir/DDMMYY/PED/.file_name

time_check(start_time)

Принимает время старта какого-либо процесса. Возвращает время в секундах, прошедшее с этого времени старта.

read_input_card()

Считывает файл data_directory.config. Возвращает массив с найстройками и строкой из данных, подлежащих обработке. Именно
от нее manticore_main.py знает все главные переменные.

directory_objects_parser(directory, pattern)

Ищет в директории directory все файлы с именами, совпадающими со строкой pattern. Возвращает строку из имен этих файлов,
разделенных пробелами. Важно!!! Строка pattern – это шаблон, написанный на языке регулярных выражений.

what_time_is_now()

Возвращает время в секундах, прошедшее с 1 января 1970.

check_and_cut_the_tail(line)

Проверяет, заканчивается ли line символом ‘\n’ - символом конца строки. Возвращает line без этого символа в конце.

square_root(expression)

Возвращает квадратный корень числа.

file_is_exist(file)

Принимает строку с абсолютным именем файла. Проверяет, существует ли такой. Возвращает True или False.

packed_bytes(rule, input_list)

Принимает правило упаковки rule массива в пакет байтов и, собственно, сам массив input_list, который необходимо упаковать.
rule должно быть записано в формате, допустимом стандартной библиотекой struct. Например: ‘hhh’ = ‘3h’ = ‘h’*3, означающее
3 идущих подряд short integer. input_list, соответственно, должен содержать 3 объекта типа short integer. На выходе функция
возвращает пакет байтов.

unpacked_from_bytes(rule, bytes_chunk)

Функция, распаковывающая пакет байтов bytes_chunk по правилу rule. rule должно быть записано в формате, допустимом стандартной
библиотекой struct. Например: ‘ccc’ = ‘3c’ = ‘c’*3, означающее 3 идущих подряд char. Возвращает функция контейнер типа tuple
(неизменяемый массив) из данных. Если rule не совпадает с правилом, по которому на самом деле были запакованы данные, функция
может не сработать или сработать некорректно. 

system_exit()

Маска для системного выхода из программы.

manticore_parser.py:

universal_parser(input_string, start_time)

Принимает на вход строку с данными для обработки из input_card.txt.
Она принимает любые объекты, разделенные пробелом - дни, отдельные файлы, "хвосты" или BSM. Также есть опция для обработки
всех данных в директории с данными.
Подробности по синтаксису этой строки - в самом input_card.txt.

Программа создает в папке manticore_1.3 временный файл .files_list.txt, в котором содержатся все файлы, которые подлежат
предобработке. Каждая строка содержит абсолютный путь одного файла, к примеру:
“/home/yaroslav/Yaroslavus_GitHub/DATA/281017/BSM17/28107017.001”.
Количество строк на одну больше количества файлов. Последняя строка файла – пустая.

manticore_multiprocessing.py:

Данная библиотека содержит в себе близнецы некоторых функций из manticore_preprocessing.py. Если в
manticore_preprocessing.py существует функция, которая в цикле запускает какие-то одинаковые процессы, то она переписана
сюда. Только в данной библиотеке эти йункции умеют запускать процессы не один за другим, а блоками по 4-8 процессов
одновременно. Выигрыш в скорости работы - 4-8 раз. Минус работы в параллельном режиме только в том, что в вывод консоли
пишут сразу несколько процессов, что создает в консоли небольшую неразбериху.

def to_process_single_file_mult(file_to_process, strings_to_write_to_mess_file):

Принимает файл file_to_process и делает с ним то же, что и to_process_single_file из manticore_preprocessing, только здесь
она делает записи о создании временных файлов не сразу в .mess.txt, а в массив strings_to_write_to_mess_file. Это сделано
потому, что в данный момент параллельно ему работают еще несколько таких же процессов, обрабатывающих другие файлы из списка.
А одновременно писать в файл .mess.txt из восьми мест нельзя. А в массив можно.  

def to_process_mult(start_time):

Принимает .files_list.txt и в цикле запускает обработку для каждого из них. От to_process из manticore_preprocessing
отличается двумя вещами:
- запускает сразу несколько (4-8) обработок одновременно.
- так как параллельные процессы не могут открывать для записи один файл .mess.txt, здесь его заполнение реализовано иначе.
Прямо в этой функции создается сквозной массив строк для записи strings_to_write_to_mess_file (доступный всем процессам).
В массив, в отличии от файла, можно писать параллельно из нескольких процессов. После отработки всех параллельных
процессов (после выхода из главного цикла функции) они выбрасывают этот массив, в котором каждый элемент - запись о
создании временного файла. После этого функция открывает на запись .mess.txt и записывает в него весь массив построчно.

def fill_the_summary_files_mult(dict_of_days, start_time):

Отличается от fill_the_summary_files из manticore_preprocessing только наличием параллельного запуска нескольких процессов.

def count_tails_range_mult(start_time):

Открывает .files_list.txt и в цикле запускает dict_of_num_min_max_in_tail_mult для каждого из них.
От to_process из manticore_preprocessing отличается двумя вещами:
- запускает сразу несколько (4-8) обработок одновременно.
- здесь запись максимального и минимального номера событий в глобальный словарь делается не в теле функции, а глубже - 
каждым процессом самостоятельно.

def dict_of_num_min_max_in_tail_mult(tail, files_list, day, dict_of_max_min):

Делает то же самое, что и dict_of_num_min_max_in_tail из manticore_preprocessing, только не возвращает минимальный и
максимальный номер события в "хвосте", а сразу сама и делает соответствующую запись в сквозном словаре.
Вместо return num_min, num_max делает:
dict_of_max_min[tail] = [num_min, num_max]
прямо внутри себя.

Остальные функции, необходимые для обработки, берутся из manticore_preprocessing.

#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

3. Работа программы manticore 1.3.

#########################################################################################################################

Все ведение предобработки производится в скрипте manticore_main_fast.py (manticore_main_slow.py). Здесь хранятся
глобальные переменные, которые должны быть доступны всем библиотекам программы - строки из input_card, глобальное время.

Об отличиях manticore_main_fast.py и manticore_main_slow.py было сказано выше, (в том числе и при описании скрипта
manticore.sh).

На нулевом этапе включается сборщик мусора, который удаляет все временные файлы. Однако это происходит только в том
слуае, если в нужном месте существует .mess.txt. Если он был удален ИЛИ СБОРЩИК МУСОРА ХОРОШО ОТРАБОТАЛ ПО ОКОНЧАНИИ
ПРЕДЫДУЩЕЙ ПРЕДОБРАБОТКИ, то отработает быстро и вхолостую. Если же .mess.txt присутствует, а файлы куда-то делись
(например, кто-то удалил самостоятельно), будет ругаться. На дальнейшую работу это не повлияет.

ИНФОРМАЦИЯ! Если по каким-то причинам сборщие мусора не работает, все временные файлы программы всегда можно удалить
из директории с датой с помощью команды:

~$ rm ./BSM{01..22}/.* ./PED/.*

Дальше - уже непосредственная работа основной программы.

Вначале считывается input_card.txt и главные переменные обработки становятся имуществом программы (описание чит.
в input_card.txt).

Включается universal_parser() из библиотеки manticore_parser. На выходе он создает .files_list.txt. Каждая его строка - 
полный путь к одному из файлов.

Фиксируется текущее время. Оно необходимо, чтобы на протяжении всей работы информировать пользователя в стандартном
выводе BASH о прошедшем времени.

Проверяется, будет ли вообще происходить предобработка или пользователь просто хочет удалить мусор/создать фиктивный
список временных файлов и проч.

Если предобработка происходить будет, то она запускается. Происходит она в два этапа:
Во время первого этапа каждый файл распаковывается, пособытийно очищается от пьедесталов. Пьедесталы также обрабатываются,
считаются сигмы, присваиваются игнор-статусы.

Во время второго этапа работа происходит не с файлами, а с "хвостами" ("хвост" - это набор файлов из директории одного
дня, у которых одинаково расширение: .001, .002, ...). Физически набор таких файлов соответствует полному набору данных
всех кластеров телескопа за две минуты. Первая двухминутка - ".001", вторая - ".002" и т.д. В каждой папке кластера
(BSMxx) лежит, соответственно, один такой файл.
Здесь создается матрица сводной информации по всем кластерам за эти две минуты. На выходе эта матрица записывается в
zzz.out файл, где zzz - это "хвост" (001, 002, ... 034 и проч.). Все zzz.out файлы лежат в директории дня.

Проверяется, выбрал ли пользователь опцию удаления временных файлов после предобработки. Если да, временные файлы,
созданные в процессе, удаляются.
 
В среднем, в зависимости от обстоятельств:
- обработка одного файла от сырого состояния до состояния .wfp длится около 300-350 мс (для одиночного процесса).
- обработка одного "хвоста" до состояния "выходной файл записан на диск":
    - в медленном режиме - около 4-5 мин;
    - в быстром режиме - около 30-45 с. 
- размер выходного файла - 200-500 Мб.
- обработка одного дня до состояния "все выходные файлы записаны на диск и находятся в папке этого дня":
     - в медленном режиме - 4,5-5 часов.
     - в быстром режиме - 1-1,5 часа.
     
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################

4. Структура временных файлов, используемых в manticore 1.3.

#########################################################################################################################

1. .fpd (fine pedestals array) – 64 float по 4 байта = 256 байт.

2. .sgm (sigma array) – 64 float по 4 байта = 256 байт.

3. .ig (ignor array) – 64 char по 1 байту – 64 байт.

4. .hdr (header) – файл, состоящий из последовательных пакетов.
Один пакет имеет структуру:
Байты 0-3 – номер 1
Байты 4-7 – номер 2
Байты 8-15 – время события.
Байт 16 – номер MAROC (равен номеру кластера). Номер лежит в 5 младших битах (справа).
Итого размер пакета равен 16 байт.

5. .wfp (without fine pedestals) – файл с почищенными амплитудами, состоящий из последовательных пакетов.
Один пакет имеет структуру:
Заголовок:
Байты 0-1 – идентификатор типа данных (должен быть равен 3032)
Байты 2-3 – размер пакета без заголовка (равен 132)
Байты 4-7 – номер 1
Байты 8-11 – номер 2
Байты 12-19 – время события.
Байт 20 – номер MAROC (равен номеру кластера). Номер лежит в 5 младших битах (справа).
Байт 21-23 – пустые байты.
Данные:
Байты 24-216 – данные.
Байты 216 – 219 – флаг конца пакета (равен 0xffffffff или -1).
Итого размер пакета равен 220 байт.

Состав пакета с данными см. п. 2, в описании функции make_clean_amplitudes_and_headers(file).

#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
-------------------------------------------------------------------------------------------------------------------------
#########################################################################################################################
